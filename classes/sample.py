import pefile
import subprocess
import networkx as nx
import pickle
import re
import os
import json
from hashlib import sha256
from minidump import minidumpfile
from classes.heap import Heap
from classes.module import Module
from classes.section import Section
from classes.function import Function
from ghidra.program.model.block import BasicBlockModel
from ghidra.program.disassemble import Disassembler


class SectionEncoder(json.JSONEncoder):
    def default(self, o):
        return o.__dict__()


class Sample:
    def __init__(self, dmp_file):
        self.dmp_file = dmp_file
        self.sample_file = os.path.splitext(self.dmp_file)[0]
        self.name = os.path.splitext(currentProgram.getName())[0]
        self.bbl_file = os.path.splitext(self.dmp_file)[0] + ".bbl"
        self.min_address = currentProgram.getMinAddress().getOffset()
        self.max_address = currentProgram.getMaxAddress().getOffset()
        # Monitor
        self.monitor = getMonitor()
        # Disassembler
        self.disassembler = Disassembler.getDisassembler(
            currentProgram, self.monitor, None)
        # Graph of all the sample
        self.G = nx.Graph()
        # PE file
        self.pe = pefile.PE(self.sample_file)
        self.base = self.pe.OPTIONAL_HEADER.ImageBase if self.pe.OPTIONAL_HEADER != None else 0x400000
        # dmp file
        self.minidump = minidumpfile.MinidumpFile.parse(self.dmp_file)
        # BasicBlockModel
        self.bbm = BasicBlockModel(currentProgram)
        # Instruction trace
        self.trace = self.parse_trace()
        # Addresses
        self.addr_to_visit = self.trace_and_nucleus()
        self.addr_visited = [0x000000]
        # Get sections
        self.sections = self.get_sections()
        # Get modules (of the dmp)
        self.modules = self.get_modules()
        # Get heaps
        self.heaps = self.get_heap()
        # External function dictionary(s)
        try:
            with open("externals.pickle", "rb") as file:
                self.externals = pickle.load(file)
        except:
            self.externals = None
            print("*\tFile .pickle not found")
        self.ext_cover = {}
        # Set for executed bbs
        self.bb_exe = set()
        # Function and API dicts
        self.functions_dict()
        # Executed address, not disass, from no sections
        self.unknown_instr = []
        # Edge coverage
        self.edge_exe = 0
        self.edge_tot = 0
        self.edge_cov = 0.0

    def __str__(self):
        return f"Analyzed {self.name}"

    def __dict__(self):
        return {
            "sample_name": self.name,
            "edge_exe": self.edge_exe,
            "edge_tot": self.edge_tot,
            "edge_cov": self.edge_cov,
            "ext_instr": {"modules": self.modules, "unknown_instr": self.unknown_instr},
            "heaps": self.heaps,
            "sections": self.sections
        }

    def get_sections(self):
        '''
        Define all the sections in a sample
        '''
        sections = []
        for pe_sec in self.pe.sections:
            section = Section(name=pe_sec.Name.decode().strip('\x00'), sample=self, start=(pe_sec.VirtualAddress + self.min_address), size=pe_sec.SizeOfRawData, read=pe_sec.__dict__[
                              'IMAGE_SCN_MEM_READ'], write=pe_sec.__dict__['IMAGE_SCN_MEM_WRITE'], exe=pe_sec.__dict__['IMAGE_SCN_MEM_EXECUTE'], sha256=pe_sec.get_hash_sha256())
            section.modified = self.modifying(section)
            sections.append(section)
        self.pe.close()
        return sections

    def modifying(self, sec):
        # Relocation table
        bytes = bytearray()
        byte_array = getBytes(toAddr(sec.start), sec.size)
        for byte in byte_array:
            if byte < 0:
                byte = 0x100 + int(hex(byte), 16)
            bytes.append(byte)

        # Relocation table
        if hasattr(self.pe, 'DIRECTORY_ENTRY_BASERELOC'):
            reloc_table = self.pe.DIRECTORY_ENTRY_BASERELOC
            reloc_addr = set()
            for reloc_entry in reloc_table:
                for reloc_data in reloc_entry.entries:
                    if sec.start - self.min_address <= reloc_data.rva and reloc_data.rva <= sec.end - self.min_address - 2:
                        reloc_addr.add(reloc_data.rva)
                    elif reloc_data.rva > sec.end - self.min_address - 2:
                        break
            byte_to_change = (self.min_address >> 16) & 0xff
            byte_correct = (self.base >> 16) & 0xff
            # takes reloc table addresses and convert the corresponding bytes
            # since the reloc table starts at the beg of pe
            # but the bytearray starts at the beg of the .text section there is an offset, usually 0x1000
            offset = sec.start - self.min_address
            # change bytes
            for addr in sorted(reloc_addr):
                if bytes[addr + 2 - offset] == byte_to_change:
                    bytes[addr + 2 - offset] = byte_correct

        # External functions
        if hasattr(self.pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                for impo in entry.imports:
                    # print(hex(a.address))
                    # relative_addr is 0xc4f6 from 0x40c1f4 when base addr is 0x400000
                    relative_addr = impo.address - self.base
                    # offset of every section
                    section_offset = sec.start - self.min_address
                    if sec.start - self.min_address <= relative_addr and relative_addr <= sec.end - self.min_address - 4:
                        if impo.hint_name_table_rva != None:
                            bytes_correct = impo.hint_name_table_rva.to_bytes(
                                4, byteorder='little')
                            # change bytes
                            for i in range(0, 4):
                                bytes[relative_addr - section_offset +
                                      i] = bytes_correct[i]
        # if sec.name == ".text":
        #     for b in bytes:
        #         print(format(b, '02x'), end=" ")

        # Calculate and compare hashes
        sha256_hash_dmp = sha256(bytes).hexdigest()
        sha256_hash_pe = sec.sha256
        if sha256_hash_pe == sha256_hash_dmp:
            return False
        else:
            return True

    def get_modules(self):
        '''
        Define all the modules
        '''
        modules = []
        for module in self.minidump.modules.modules[1:]:
            modules.append(
                Module(name=module.name, start=module.baseaddress, end=module.endaddress))
        return modules

    def get_heap(self):
        '''
        Define heaps
        '''
        heaps = []
        pattern = r"Segment at ([0-9a-fA-F]+) to ([0-9a-fA-F]+)"
        command = 'echo !heap -a;q | "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\kd.exe" -y srv* -z ' + self.dmp_file
        try:
            result = subprocess.run(
                command, shell=True, check=True, capture_output=True, text=True)
            for line in result.stdout.splitlines():
                match = re.search(pattern, line)
                if match:
                    start = int(match.group(1), 16)
                    size = int(match.group(2), 16)
                    for ms in self.minidump.memory_segments_64.memory_segments:
                        if ms.start_virtual_address == start and ms.size <= size:
                            offset = ms.start_file_address
                            heaps.append(Heap(start, size, offset))
        except:
            print("*\tWinDbg can't analyze the heap")
        return heaps

    def find_section(self, address):
        '''
        Find the section containing the address
        '''
        address = toAddr(address).getOffset()
        for sec in self.sections:
            if sec.contains(address):
                return sec
        return None

    def find_function(self, address):
        address = toAddr(address)
        for sec in self.sections:
            # Take functions existent
            f = getFunctionContaining(address)
            if f == None:
                # Or create them
                f = createFunction(address, "FUN_" + address.toString())
            if f != None and f.toString() in sec.functions:
                return sec.functions[f.toString()]
        return None

    def json_sections(self):
        '''
        Create json file for the sections
        '''
        # json_string = json.dumps(
        #     self.sections[0], indent=4, cls=SectionEncoder)
        # print(json_string)
        results_folder = "outputs/"
        if not os.path.exists(results_folder):
            os.makedirs(results_folder)
        with open(results_folder + self.name + ".json", 'w') as file:
            json.dump(self, file, indent=4, cls=SectionEncoder)

    def trace_and_nucleus(self):
        '''
        Add executed instructions and run Nucleus tool to get the functions
        '''
        addr_to_visit = []
        # Instruction executed
        for addr in self.trace:
            addr_to_visit.append(toAddr(addr).getOffset())
        # Nucleus
        # It's wsl path (/mnt/c/Users...)
        linux_file_path = "/mnt/" + \
            self.dmp_file[0].lower() + (os.path.normpath(self.dmp_file)
                                        [2:]).replace('\\', '/')
        ret_code = os.system('wsl nucleus/nucleus -t dmp -a x86 -l 32 -e ' +
                             linux_file_path + ' -d linear -f 2>&1 > nucleus.txt')
        if ret_code == 0:
            with open("nucleus.txt", "r") as file:
                for entry in file.readlines():
                    address = re.findall('0x.{16}', entry)
                    addr = toAddr(''.join(address))
                    addr_to_visit.append(addr.getOffset())
        else:
            print("*\tnucleus can't analyze the minidump")
        os.remove("nucleus.txt")
        return addr_to_visit

    def functions_dict(self):
        # Create function dictionary
        for section in self.sections:
            if section.executable_flag:
                for addr in self.addr_to_visit:
                    if section.contains(addr):
                        addr = toAddr(addr)
                        func = getFunctionContaining(addr)
                        if func == None:
                            func = createFunction(addr, "FUN_"+addr.toString())
                        if func != None:
                            section.functions[func.toString()] = Function(
                                func.toString(), func.getBody())

    def parse_trace(self):
        bbl_string = open(self.bbl_file).read()
        bbl_list = re.findall('.{1,8}', bbl_string)
        return [int(addr, 16) for addr in bbl_list]
