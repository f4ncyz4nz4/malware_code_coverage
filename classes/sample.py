import pefile
import subprocess
import networkx as nx
import pickle
import re
import os
import json
from hashlib import sha256
from minidump import minidumpfile
from classes.heap import Heap
from classes.module import Module
from classes.section import Section
from ghidra.program.model.block import BasicBlockModel


class SectionEncoder(json.JSONEncoder):
    def default(self, o):
        return o.__dict__()


class Sample:
    def __init__(self, dmp_file):
        self.dmp_file = dmp_file
        self.sample_file = self.dmp_file.split(".")[0]
        self.name = currentProgram.getName().split(".")[0]
        self.bbl_file = self.dmp_file[:-3]+"bbl"
        self.min_address = currentProgram.getMinAddress().getOffset()
        self.max_address = currentProgram.getMaxAddress().getOffset()
        # Graph of all the sample
        self.G = nx.Graph()
        # PE file
        self.pe = pefile.PE(self.sample_file)
        # dmp file
        self.minidump = minidumpfile.MinidumpFile.parse(self.dmp_file)
        # BasicBlockModel
        self.bbm = BasicBlockModel(currentProgram)
        # Instruction trace
        self.trace = self.parse_trace()
        # Addresses
        self.addr_to_visit = self.trace_and_nucleus()
        self.addr_visited = [0x000000]
        # Get sections
        self.sections = self.getSections()
        # Get modules (of the dmp)
        self.modules = self.getModules()
        # Get heaps
        self.heaps = self.getHeap()
        # Self modifying code
        self.modified = self.self_modifying()
        # External function dictionary(s)
        try:
            with open("externals.pickle", "rb") as file:
                self.externals = pickle.load(file)
        except:
            print("->\tfile .pickle not found")
            raise Exception
        self.ext_cover = {}
        # Set for executed bbs
        self.bb_exe = set()
        # Function and API dicts
        for sec in self.sections:
            sec.functions_dict()
        # Executed address, not disass, from no sections
        self.unknown_instr = []
        # Edge coverage
        self.edge_coverage = 0.0

    def __str__(self):
        return f"Analyzed {self.name}"

    def __dict__(self):
        return {
            "sample_name": self.name,
            "edge_coverage": self.edge_coverage,
            "modifying_text_section": self.modified,
            "ext_instr": {"modules": self.modules, "unknown_instr": self.unknown_instr},
            "heaps": self.heaps,
            "sections": self.sections
        }

    def getSections(self):
        '''
        Define all the sections in a sample
        '''
        sections = []
        for sec in self.pe.sections:
            sections.append(Section(name=sec.Name.decode().strip('\x00'), sample=self, start=(sec.VirtualAddress + self.min_address),
                            size=sec.SizeOfRawData, exe=sec.__dict__['IMAGE_SCN_MEM_EXECUTE'], sha256=sec.get_hash_sha256()))
        self.pe.close()
        return sections

    def getModules(self):
        '''
        Define all the modules
        '''
        modules = []
        for module in self.minidump.modules.modules[1:]:
            modules.append(
                Module(name=module.name, start=module.baseaddress, end=module.endaddress))
        return modules

    def getHeap(self):
        '''
        Define heaps
        '''
        heaps = []
        pattern = r"Segment at ([0-9a-fA-F]+) to ([0-9a-fA-F]+)"
        command = 'echo !heap -a;q | "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\kd.exe" -y srv* -z ' + self.dmp_file
        try:
            result = subprocess.run(
                command, shell=True, check=True, capture_output=True, text=True)
        except Exception as e:
            print("*\tWinDbg can't analyze the heap -> " + e)
        for line in result.stdout.splitlines():
            match = re.search(pattern, line)
            if match:
                start = int(match.group(1), 16)
                size = int(match.group(2), 16)
                for ms in self.minidump.memory_segments_64.memory_segments:
                    if ms.start_virtual_address == start and ms.size <= size:
                        offset = ms.start_file_address
                        heaps.append(Heap(start, size, offset))
        return heaps

    def find_section(self, address):
        '''
        Find the section containing the address
        '''
        address = toAddr(address).getOffset()
        for sec in self.sections:
            if sec.contains(address):
                return sec
        return None

    def find_function(self, address):
        address = toAddr(address)
        for sec in self.sections:
            # Take functions existent
            f = getFunctionContaining(address)
            if f == None:
                # Or create them
                f = createFunction(address, "FUN_" + address.toString())
            if f != None and f.toString() in sec.functions:
                return sec.functions[f.toString()]
        return None

    def json_sections(self):
        '''
        Create json file for the sections
        '''
        # json_string = json.dumps(
        #     self.sections[0], indent=4, cls=SectionEncoder)
        # print(json_string)
        reults_folder = "outputs/"
        if not os.path.exists(reults_folder):
            os.makedirs(reults_folder)
        with open(reults_folder + self.name + ".json", 'w') as file:
            json.dump(self, file, indent=4, cls=SectionEncoder)

    def trace_and_nucleus(self):
        '''
        Add executed instructions and run Nucleus tool to get the functions
        '''
        addr_to_visit = []
        # Instruction executed
        for addr in self.trace:
            addr_to_visit.append(toAddr(addr).getOffset())
        # Nucleus
        # It's wsl path (/mnt/c/Users...)
        linux_file_path = "/mnt/" + \
            self.dmp_file[0].lower() + (os.path.normpath(self.dmp_file)
                                        [2:]).replace('\\', '/')
        ret_code = os.system('wsl nucleus/nucleus -t dmp -a x86 -l 32 -e ' +
                             linux_file_path + ' -d linear -f 2>&1 > nucleus.txt')
        if ret_code == 0:
            with open("nucleus.txt", "r") as file:
                for entry in file.readlines():
                    address = re.findall('0x.{16}', entry)
                    addr = toAddr(''.join(address))
                    addr_to_visit.append(addr.getOffset())
        else:
            print("*\tnucleus can't analyze the minidump")
        os.remove("nucleus.txt")
        return addr_to_visit

    def parse_trace(self):
        bbl_string = open(self.bbl_file).read()
        bbl_list = re.findall('.{1,8}', bbl_string)
        return [int(addr, 16) for addr in bbl_list]

    def self_modifying(self):
        if hasattr(self.pe, 'DIRECTORY_ENTRY_BASERELOC'):
            # reloc entries
            reloc_table = self.pe.DIRECTORY_ENTRY_BASERELOC
            tmp = []
            text_sec = self.sections[0]
            for reloc_entry in reloc_table:
                # `text_sec.end - self.min_address` is used to find the relative end of .text section
                if reloc_entry.struct.VirtualAddress >= text_sec.end - self.min_address:
                    break
                for reloc_data in reloc_entry.entries:
                    tmp.append(reloc_data.rva)
            # dmp .text section
            bytes = bytearray()
            byte_array = getBytes(toAddr(text_sec.start), text_sec.size)
            for byte in byte_array:
                if byte < 0:
                    byte = 0x100 + int(hex(byte), 16)
                bytes.append(byte)
            # byte to change
            byte_to_change = (self.min_address >> 16) & 0xff
            # takes reloc table addresses and convert the corresponding bytes
            for addr in tmp:
                # since the reloc table starts at the beg of pe
                # but the bytearray starts at the beg of the .text section there is an offset, usually 0x1000
                offset = text_sec.start - self.min_address
                if bytes[addr + 2 - offset] == byte_to_change:
                    bytes[addr + 2 - offset] = 0x40
                # else:
                #     print(hex(0xc20000+addr+2))
            # calculate and compare hashes
            sha256_hash_dmp = sha256(bytes).hexdigest()
            sha256_hash_pe = text_sec.sha256
            if sha256_hash_pe == sha256_hash_dmp:
                return False
            else:
                return True
        else:
            print("No relocation table found in the PE file")
            return None
