from minidump import minidumpfile
from capstone import *
import re


def check_ret(inst):
    if inst.mnemonic == "ret":
        return True
    return False


def check_null(code):
    if code[:7] == b'\x00\x00\x00\x00\x00\x00\x00':
        return True
    return False


def check_cond_jmp(inst, level=0):
    if inst.mnemonic == "jmp" and re.match(r'0x.{1,8}', inst.op_str):
        explore_jump(int(inst.op_str, 16), level)


def check_ind_jump(inst, va, level=0):
    """mov	eax, 0x405030 jmp	eax

    Args:
        i (_type_): instruction from md.disasm

    Returns:
        Bool: True if there is an indirect jump, False otherwise
    """
    if inst.mnemonic == "mov" and re.match(r'..., 0x.{1,8}', inst.op_str):
        reg = inst.op_str[:3]
        code = minidump_reader.read(va + inst.size, 0x20)
        jnst = next(md.disasm(code, va))
        if jnst.mnemonic == "jmp" and jnst.op_str == reg:
            explore_jump(int(inst.op_str[5:], 16), level)


def check_call(inst, level=0):
    if inst.mnemonic == "call" and re.match(r'0x.{1,8}', inst.op_str):
        explore_function(int(inst.op_str, 16), level+1)


def check_ind_call(inst, level=0):
    # call	dword ptr [0x40406c]
    if inst.mnemonic == "call" and re.search(r'\[0x.{1,8}\]', inst.op_str):
        addr = re.search(r'0x[a-f0-9]{1,8}', inst.op_str).group()
        code = minidump_reader.read(int(addr, 16), 0x3)
        f_addr = '0x' + ''.join('{:02x}'.format(x) for x in list(code))
        print(f_addr)
        explore_function(int(f_addr, 16), level+1)


def explore_function(va, level):
    print("\n---------- sub_%s ----------" % hex(va)[2:])
    first_it = True
    tabs = "\t" * level
    while first_it or not check_ret(inst):
        code = minidump_reader.read(va, 0x20)
        if check_null(code):
            break
        for inst in md.disasm(code, va):
            print(f"{tabs}{hex(inst.address)}:\t{inst.mnemonic}\t{inst.op_str}")
            check_call(inst, level)
            # check_ind_call(inst, level)
            # check_cond_jmp(inst, level)
            check_ind_jump(inst, va, level)
            break
        va += inst.size
        if first_it:
            first_it = False
    print("------------ end ------------\n")


def explore_jump(va, level):
    # print("\n---------- jump_%s ----------" % hex(va)[2:])
    first_it = True
    tabs = "\t" * level
    print(f"{tabs}    |")
    print(f"{tabs}    v")
    while first_it or not check_ret(inst):
        code = minidump_reader.read(va, 0x20)
        if check_null(code):
            break
        for inst in md.disasm(code, va):
            print(f"{tabs}{hex(inst.address)}:\t{inst.mnemonic}\t{inst.op_str}")
            check_call(inst, level)
            # check_ind_call(inst, level)
            # check_cond_jmp(inst, level)
            check_ind_jump(inst, va, level)
            break
        va += inst.size
        if first_it:
            first_it = False
    # print("------------ end ------------\n")
    print(f"{tabs}    |")
    print(f"{tabs}    v")


def main():
    print("### START ###")
    for bbl in bbl_list:
        va = int(bbl, 16)
        if va > 0:
            code = minidump_reader.read(va, 0x20)
            instruction = next(md.disasm(code, va))
            print("->0x%x:\t%s\t%s" % (instruction.address,
                  instruction.mnemonic, instruction.op_str))
            check_call(instruction)
            # check_ind_call(instruction)
            # check_cond_jmp(instruction)
            check_ind_jump(instruction, va)
    print("### END ###")


md = Cs(CS_ARCH_X86, CS_MODE_32)
minidump_file = minidumpfile.MinidumpFile.parse(
    "./1d713ad7ee3a43432d6188707943ee9ef07241bbc7bda376a068989d7a248143.dmp")
minidump_reader = minidump_file.get_reader()

bbl_string = open(
    './1d713ad7ee3a43432d6188707943ee9ef07241bbc7bda376a068989d7a248143.bbl').read()
bbl_list = re.findall('.{1,8}', bbl_string)

if __name__ == "__main__":
    main()
