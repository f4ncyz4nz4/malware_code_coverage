import subprocess
import pickle
import networkx as nx
import re
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.program.model.block import BasicBlockModel


def bytesToAddr(bytes):
    b_list = []
    for byte in bytes:
        if byte < 0:
            byte = 0x100 + int(hex(byte), 16)
        b_list.insert(0, byte)
    hex_address = "0x" + "".join(format(b, '02x') for b in b_list)
    return hex_address


def functionsDict():
    dict = {}
    for addr in addr_to_visit:
        addr = toAddr(addr)
        func = getFunctionContaining(addr)
        if func == None:
            func = createFunction(addr, "FUN_"+addr.toString())
        if func != None:
            dict[func.toString()] = (0, 0)
    return dict


def checkIndirectBlocks(bb_addr):
    inst = getInstructionAt(bb_addr)
    while True:
        if inst == None or bbm.getFirstCodeBlockContaining(inst.getInstructionContext().getAddress(),
                                                           monitor).getFirstStartAddress() != bb_addr:
            break
        matches = re.findall(r'0x\w{1,8}', inst.toString())
        if len(matches) > 0:
            addr = toAddr(matches[0])
            if addr.getOffset() > currentProgram.getMinAddress().getOffset() and addr.getOffset() < currentProgram.getMaxAddress().getOffset():
                if re.match(r'CALL .*\[0x.{1,8}\]', inst.toString()):
                    hex_address = bytesToAddr(getBytes(addr, 4))
                    addr_to_visit.insert(0, toAddr(hex_address).getOffset())
                else:
                    addr_to_visit.insert(0, addr.getOffset())
        inst = inst.getNext()


def bb_coverage():
    used_addresses = set()
    coverage = 0.0
    for node in G.nodes():
        bb = bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
        if bb != None:
            start = max(bb.getMinAddress().getOffset(),
                        0x401000)
            end = min(bb.getMaxAddress().getOffset(), 0x404000)
            if end > start:
                slot = (end - start)
                # Check if any address within the range is already used
                for address in range(start, end):
                    if address in used_addresses:
                        slot -= 1
                # Update the used addresses
                size = 0x3000
                coverage += slot / size
                for addr in range(start, end):
                    used_addresses.add(addr)
    print(
        f"Coverage:\t{coverage:.4f}")


def bb_executed(file):
    bbl_string = open(file).read()
    bbl_list = re.findall('.{1,8}', bbl_string)
    not_seen = set()
    for addr in bbl_list:
        bb = bbm.getFirstCodeBlockContaining(toAddr(addr), monitor)
        if bb != None:
            if G.has_node(bb.getFirstStartAddress().toString()):
                bb_exe.add(bb.getFirstStartAddress().toString())
            elif bb.getFirstStartAddress().toString() != "00000000":
                not_seen.add(bb.getFirstStartAddress().toString())
    if len(not_seen) > 0:
        print("The following bb are not visited:")
        for string in not_seen:
            print("\t[*] {} ".format(string))
    return len(bb_exe)


def bb_functions():
    # Count bb disassembled
    for node in G.nodes():
        f = getFunctionContaining(toAddr(node))
        if f == None:
            f = createFunction(addr, "FUN_"+addr.toString())
        if f != None and f.toString() in function_dict:
            value = function_dict[f.toString()]
            function_dict[f.toString()] = (value[0], value[1] + 1)
    # Count bb executed
    for bb in bb_exe:
        f = getFunctionContaining(toAddr(bb))
        if f == None:
            f = createFunction(addr, "FUN_"+addr.toString())
        if f != None and f.toString() in function_dict:
            value = function_dict[f.toString()]
            function_dict[f.toString()] = (value[0] + 1, value[1])
    print("")


def basic_block(address):
    '''find all the basic blocks given an address.
    Args:
        address (ghidra.program.model.listing.Program): address to search
    '''
    bb = bbm.getCodeBlockAt(address, monitor)
    if bb != None:
        G.add_node(bb.getFirstStartAddress().toString(), color="blue")
        # check if there are other posible functions not called directly
        checkIndirectBlocks(bb.getFirstStartAddress())
        dests = bb.getDestinations(monitor)
        while (dests.hasNext()):
            dbb = dests.next()
            # add adresses to the list
            if dbb != None:
                addr_to_visit.insert(0, dbb.getReference().getOffset())
                # Create the node for the basic block and link
                G.add_node(dbb.getReference().toString(), color="blue")
                print("\t[*] {} -> {}".format(bb.getFirstStartAddress(),
                                              dbb.getReference()), file=log)
                G.add_edge(bb.getFirstStartAddress().toString(),
                           dbb.getReference().toString(), color="black")
    # else:
        # print("-->can NOT create bb {}".format(address.toString()))


def main():
    while len(addr_to_visit) > 0:
        addr = addr_to_visit.pop()
        if not addr in addr_visited:
            basic_block(toAddr(addr))
            addr_visited.append(addr)
    num_node = G.number_of_nodes()
    num_edge = G.number_of_edges()
    with open('graph.pickle', 'wb') as file:
        pickle.dump(G, file)
    print("Number of nodes:\t{}".format(num_node))
    print("Number of edges:\t{}".format(num_edge))
    print("\nSTATS:")
    bb_coverage()
    num_exec = bb_executed(currentProgram.getName()[:-3]+"bbl")
    print(
        f"Execution ratio:\t{(num_exec / num_node):.4f}\t(bb executed:{num_exec})")
    bb_functions()
    print("Function_name\ttotal_bb - executed_bb")
    for key, value in function_dict.items():
        print(key+"\t" + str(value[0]) + "-" + str(value[1]))


# Starts execution here
if __name__ == "__main__":
    print("Start")

    G = nx.Graph()
    monitor = ConsoleTaskMonitor()
    bbm = BasicBlockModel(currentProgram)
    # Run the shell command
    command = "nucleus/nucleus -t dmp -a x86 -e 1d713ad7ee3a43432d6188707943ee9ef07241bbc7bda376a068989d7a248143.dmp -d linear -f"
    result = subprocess.run(command, shell=True,
                            capture_output=True, text=True)
    bb_exe = set()
    addr_to_visit = []
    for entry in result.stdout.splitlines():
        address = re.findall('0x.{16}', entry)
        addr = toAddr(''.join(address))
        addr_to_visit.append(addr.getOffset())
    function_dict = functionsDict()
    addr_visited = [0x000000]
    log = open("log.txt", "w")
    main()
    log.close()
    # n = open("nodes.txt", "w")
    # for no in G.nodes():
    #    print(no, file=n)
    # n.close()
    # all_f = open("all_bbs.txt").readlines()
    # for line in all_f:
    #    if toAddr(line).getOffset() > 0x401000 and toAddr(line).getOffset() < 0x403fff:
    #        if not G.has_node(toAddr(line).toString()):
    #            print("MISSING-> " + toAddr(line).toString())

    print("End")

# opt/ghidra_10.2.2/support/analyzeHeadless . CodeCoverage -import /home/ippo/Desktop/malware_code_coverage_project/malware_code_coverage/1d713ad7ee3a43432d6188707943ee9ef07241bbc7bda376a068989d7a248143.dmp -scriptPath /home/ippo/Desktop/malware_code_coverage_project/malware_code_coverage/ -postscript ghidra_postscript.py -deleteProject -processor x86:LE:32:default -loader BinaryLoader -loader-blockName sample -loader-baseAddr 401000 -loader-fileOffset 0x6101d -loader-length 0x9000

# networkx
# ghidra headless
# picke.dump

# .text 00401000 00403fff 0x3000 true(R) false(W) true(X)
