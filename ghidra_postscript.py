import pefile
import subprocess
import pickle
import networkx as nx
import re
from ghidra.program.model.block import BasicBlockModel


class Section:
    def __init__(self, name, start, size, exe):
        self.name = name
        self.start = start
        self.size = size
        self.end = start+size
        self.executable_flag = exe
        self.disass = 0.0
        self.bbs = 0
        self.coverage = 0.0
        self.not_seen = set()
        self.function_dict = {}
        self.api_dict = {}
        self.api_not_exec = {}

    def print_dicts(self):
        string = "Function_name\texe_bb-tot_bb  exe_api-tot_api  api_not_executed\n"
        for (key1, value1), (key2, value2), (key3, value3) in zip(self.function_dict.items(), self.api_dict.items(), self.api_not_exec.items()):
            string += "\t" + key1 + "\t" + \
                str(value1[0]) + "-" + str(value1[1]) + "  " + \
                str(value2[0]) + "-" + str(value2[1])
            if len(value3) > 0:
                string += "  " + str(value3) + "\n"
            else:
                string += "\n"
        return string

    def __str__(self):
        if self.executable_flag:
            string = f"Section: {self.name}\nStart: {hex(self.start)}\nSize: {hex(self.size)}\nEnd: {hex(self.end)}\nExecutable: {self.executable_flag}\n\nDisassembly ratio: {self.disass:.4f}\nCoverage: {self.coverage:.4f}\nBBs executed but not found: {self.not_seen}\n\n" + self.print_dicts()
        else:
            string = f"Section: {self.name}\nStart: {hex(self.start)}\nSize: {hex(self.size)}\nEnd: {hex(self.end)}\nExecutable: {self.executable_flag}\n"
        return string

    @staticmethod
    def find_section(address):
        for sec in sections:
            if address > sec.start and address < sec.end:
                return sec
        return None


def bytesToAddr(bytes):
    b_list = []
    for byte in bytes:
        if byte < 0:
            byte = 0x100 + int(hex(byte), 16)
        b_list.insert(0, byte)
    hex_address = "0x" + "".join(format(b, '02x') for b in b_list)
    return hex_address


def functionsDict(type):
    # Create function dictionary
    dict = {}
    for addr in addr_to_visit:
        addr = toAddr(addr)
        func = getFunctionContaining(addr)
        if func == None:
            func = createFunction(addr, "FUN_"+addr.toString())
        if func != None:
            if type == "tuple":
                dict[func.toString()] = (0, 0)
            elif type == "list":
                dict[func.toString()] = []
    return dict


def getSections():
    '''
    Define all the sections in a pe file
    '''
    sections = []
    pe = pefile.PE(str(getProgramFile()).split(".")[0])
    for sec in pe.sections:
        sections.append(Section(sec.Name.decode().strip('\x00'), sec.VirtualAddress +
                        currentProgram.getMinAddress().getOffset(), sec.SizeOfRawData, sec.__dict__['IMAGE_SCN_MEM_EXECUTE']))
    pe.close()
    return sections


def checkIndirectBlocks(bb_addr):
    inst = getInstructionAt(bb_addr)
    ext_in_bb = []
    while True:
        # Continue for all the basic block
        if inst == None or bbm.getFirstCodeBlockContaining(inst.getInstructionContext().getAddress(),
                                                           monitor).getFirstStartAddress() != bb_addr:
            break
        matches = re.findall(r'0x\w{1,8}', inst.toString())
        if len(matches) > 0:
            addr = toAddr(matches[0])
            if addr.getOffset() > currentProgram.getMinAddress().getOffset() and addr.getOffset() < currentProgram.getMaxAddress().getOffset():
                match = re.match(r'CALL .*\[(0x.{1,8})\]', inst.toString())
                if match:
                    # Indirect address
                    hex_address = bytesToAddr(getBytes(addr, 4))
                    addr_to_visit.insert(0, toAddr(hex_address).getOffset())

                    if match.group(1)[2:] in externals:
                        ext_in_bb.append(externals[match.group(1)[2:]])
                else:
                    # Direct address
                    addr_to_visit.insert(0, addr.getOffset())
        inst = inst.getNext()
    if ext_in_bb:
        ext_cover[bb_addr.toString()] = ext_in_bb


def bb_disassembled_ratio():
    '''
    Compute the disassembled ratio for the executable addresses
    '''
    used_addresses = set()
    for node in G.nodes():
        section = Section.find_section(toAddr(int(node, 16)).getOffset())
        if section != None:
            section.bbs += 1
        # else:
        #     print(f"No section for> {toAddr(int(node, 16)).toString()}")
        bb = bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
        if bb != None:
            for sec in sections:
                if sec.executable_flag == True and sec.size > 0x0:
                    if bb.getMinAddress().getOffset() > sec.start and bb.getMaxAddress().getOffset() < sec.end:
                        start = max(bb.getMinAddress().getOffset(), sec.start)
                        end = min(bb.getMaxAddress().getOffset(), sec.end)
                        if end > start:
                            slot = (end - start)
                            # Check if any address within the range is already used
                            for address in range(start, end):
                                if address in used_addresses:
                                    slot -= 1
                            # Update the used addresses
                            sec.disass += slot
                            for addr in range(start, end):
                                used_addresses.add(addr)
    for sec in sections:
        sec.disass = sec.disass / sec.size


def bb_coverage():
    '''
    Compute the executed bbs based on the trace file
    '''
    bbl_string = open(str(getProgramFile())[:-3]+"bbl").read()
    bbl_list = re.findall('.{1,8}', bbl_string)
    not_seen = set()
    for addr in bbl_list:
        bb = bbm.getFirstCodeBlockContaining(toAddr(addr), monitor)
        if bb != None:
            section = Section.find_section(
                bb.getFirstStartAddress().getOffset())
            if G.has_node(bb.getFirstStartAddress().toString()):
                bb_exe.add(bb.getFirstStartAddress().toString())
                section.coverage += 1
            elif bb.getFirstStartAddress().toString() != "00000000":
                not_seen.add(bb.getFirstStartAddress().toString())
                section.not_seen.add(bb.getFirstStartAddress().toString())
    for sec in sections:
        sec.coverage = sec.coverage / sec.bbs


def bb_functions():
    # Count bb disassembled
    for node in G.nodes():
        sec = Section.find_section(toAddr(int(node, 16)).getOffset())
        if sec == None:
            continue
        # Take functions existent
        f = getFunctionContaining(toAddr(node))
        if f == None:
            # Or create them
            f = createFunction(addr, "FUN_"+addr.toString())
        if f != None and f.toString() in sec.function_dict:
            value = sec.function_dict[f.toString()]
            sec.function_dict[f.toString()] = (value[0], value[1] + 1)
            if node in ext_cover:
                value = sec.api_dict[f.toString()]
                sec.api_dict[f.toString()] = (
                    value[0], value[1] + len(ext_cover[node]))
                # Put in the list all the api for that function
                api_list = sec.api_not_exec[f.toString()]
                api_list.extend(ext_cover[node])
                sec.api_not_exec[f.toString()] = api_list
    # Count bb executed
    for bb in bb_exe:
        sec = Section.find_section(toAddr(bb).getOffset())
        if sec == None:
            continue
        f = getFunctionContaining(toAddr(bb))
        if f == None:
            f = createFunction(addr, "FUN_"+addr.toString())
        if f != None and f.toString() in sec.function_dict:
            value = sec.function_dict[f.toString()]
            sec.function_dict[f.toString()] = (value[0] + 1, value[1])
            if bb in ext_cover:
                value = sec.api_dict[f.toString()]
                sec.api_dict[f.toString()] = (
                    value[0] + len(ext_cover[bb]), value[1])
                # Remove the api called
                api_list = sec.api_not_exec[f.toString()]
                for api in ext_cover[bb]:
                    if api in api_list:
                        api_list.remove(api)
                sec.api_not_exec[f.toString()] = api_list


def basic_block(address):
    bb = bbm.getCodeBlockAt(address, monitor)
    if bb != None:
        G.add_node(bb.getFirstStartAddress().toString(), color="blue")
        # check if there are other posible functions not called directly
        checkIndirectBlocks(bb.getFirstStartAddress())
        dests = bb.getDestinations(monitor)
        while (dests.hasNext()):
            dbb = dests.next()
            # add adresses to the list
            if dbb != None:
                addr_to_visit.insert(0, dbb.getReference().getOffset())
                # Create the node for the basic block and link
                G.add_node(dbb.getReference().toString(), color="blue")
                print("\t[*] {} -> {}".format(bb.getFirstStartAddress(),
                      dbb.getReference()), file=log)
                G.add_edge(bb.getFirstStartAddress().toString(),
                           dbb.getReference().toString(), color="black")


def main():
    while len(addr_to_visit) > 0:
        addr = addr_to_visit.pop()
        if not addr in addr_visited:
            basic_block(toAddr(addr))
            addr_visited.append(addr)
    # Export the graph
    with open('graph.pickle', 'wb') as file:
        pickle.dump(G, file)
    # Stats
    num_node = G.number_of_nodes()
    num_edge = G.number_of_edges()
    print("STATS:\n", file=stats)
    print("Number of nodes:\t{}".format(num_node), file=stats)
    print("Number of edges:\t{}\n".format(num_edge), file=stats)
    bb_disassembled_ratio()
    bb_coverage()
    bb_functions()
    for section in sections:
        print(section, file=stats)


# Starts execution here
if __name__ == "__main__":
    print("Start")

    G = nx.Graph()
    monitor = getMonitor()
    bbm = BasicBlockModel(currentProgram)
    addr_to_visit = []
    addr_visited = [0x000000]
    # Nucleus
    command = "nucleus/nucleus -t dmp -a x86 -l 32 -e " + \
        str(getProgramFile()) + " -d linear -f"
    result = subprocess.run(command, shell=True,
                            capture_output=True, text=True)
    for entry in result.stdout.splitlines():
        address = re.findall('0x.{16}', entry)
        addr = toAddr(''.join(address))
        addr_to_visit.append(addr.getOffset())
    # Set for executed bbs
    bb_exe = set()
    # External function dictionary
    try:
        with open("externals.pickle", "rb") as file:
            externals = pickle.load(file)
    except:
        print("->\tfile .pickle not found")
    ext_cover = {}
    # Get section
    sections = getSections()
    # Function and API dicts
    for sec in sections:
        if sec.executable_flag:
            sec.function_dict = functionsDict("tuple")
            sec.api_dict = functionsDict("tuple")
            sec.api_not_exec = functionsDict("list")
    log = open("log.txt", "w")
    stats = open(
        "stats/" + (currentProgram.getName().split(".")[0]) + ".stats", "w")
    main()
    stats.close()
    log.close()

    print("End")

# opt/ghidra_10.2.2/support/analyzeHeadless . CodeCoverage -import /home/ippo/Desktop/malware_code_coverage_project/malware_code_coverage/1d713ad7ee3a43432d6188707943ee9ef07241bbc7bda376a068989d7a248143.dmp -scriptPath /home/ippo/Desktop/malware_code_coverage_project/malware_code_coverage/ -postscript ghidra_postscript.py -deleteProject -processor x86:LE:32:default -loader BinaryLoader -loader-blockName sample -loader-baseAddr 401000 -loader-fileOffset 0x6101d -loader-length 0x9000
