import pefile
import subprocess
import pickle
import networkx as nx
import re
import json
from json import JSONEncoder
from hashlib import sha256
from ghidra.program.model.block import BasicBlockModel


class SectionEncoder(JSONEncoder):
    def default(self, o):
        return o.__dict__()


class Function:
    def __init__(self, name):
        self.name = name
        self.exe_bb = 0
        self.tot_bb = 0
        self.exe_api = 0
        self.tot_api = 0
        self.api_not_executed = []

    def __dict__(self):
        return {
            "name": self.name,
            "exe_bb": self.exe_bb,
            "tot_bb": self.tot_bb,
            "exe_api": self.exe_api,
            "tot_api": self.tot_api,
            "api_not_executed": self.api_not_executed
        }


class Section:
    def __init__(self, name, sample, start, size, exe, sha256):
        self.name = name
        self.sample = sample
        self.start = start
        self.size = size
        self.end = start+size
        self.executable_flag = exe
        self.sha256 = sha256
        self.disass = 0.0
        self.bbs = 0
        self.coverage = 0.0
        self.not_seen = []
        self.not_seen_set = set()
        self.functions = {}

    def __str__(self):
        return f"Section: {self.name}\nStart: {hex(self.start)}\nSize: {hex(self.size)}\nEnd: {hex(self.end)}\nExecutable: {self.executable_flag}\n\nDisassembly ratio: {self.disass:.4f}\nCoverage: {self.coverage:.4f}\nBBs executed but not found: {self.not_seen}\n\n"

    def __dict__(self):
        return {
            "name": self.name,
            "start": hex(self.start),
            "size": hex(self.size),
            "end": hex(self.end),
            "executable": self.executable_flag,
            "sha256": self.sha256,
            # "disassembled_bbs": self.bbs,
            "disassembly_ratio": self.disass,
            "coverage": self.coverage,
            "bbs_not_executed": self.not_seen,
            "functions": list(self.functions.values())
        }

    def functions_dict(self):
        # Create function dictionary
        if self.executable_flag:
            for addr in self.sample.addr_to_visit:
                if self.contain(addr):
                    addr = toAddr(addr)
                    func = getFunctionContaining(addr)
                    if func == None:
                        func = createFunction(addr, "FUN_"+addr.toString())
                    if func != None:
                        self.functions[func.toString()] = Function(
                            func.toString())

    def contain(self, address):
        if address >= self.start and address <= self.end:
            return True
        return False


class Sample:
    def __init__(self, dmp_file):
        self.dmp_file = dmp_file
        self.sample_file = self.dmp_file.split(".")[0]
        self.name = currentProgram.getName().split(".")[0]
        self.bbl_file = self.dmp_file[:-3]+"bbl"
        self.min_address = currentProgram.getMinAddress().getOffset()
        self.max_address = currentProgram.getMaxAddress().getOffset()
        # PE file
        self.pe = pefile.PE(self.sample_file)
        # BasicBlockModel
        self.bbm = BasicBlockModel(currentProgram)
        # Instruction trace
        self.trace = self.parse_trace()
        # Addresses
        self.addr_to_visit = self.trace_and_nucleus()
        self.addr_visited = [0x000000]
        # Get section
        self.sections = self.getSections()
        # Self modifying code
        self.modified = self.self_modifying()
        # External function dictionary(s)
        try:
            with open("externals.pickle", "rb") as file:
                self.externals = pickle.load(file)
        except:
            print("->\tfile .pickle not found")
            raise Exception
        self.ext_cover = {}
        # Set for executed bbs
        self.bb_exe = set()
        # Function and API dicts
        for sec in self.sections:
            sec.functions_dict()
        # Executed address, not disass, from no sections
        self.unknown_sec = []

    def __str__(self):
        return f"Analyzed {self.name}"

    def __dict__(self):
        return {
            "sample_name": self.name,
            "self_modifying code": self.modified,
            "unknown_addrs": self.unknown_sec,
            "sections": self.sections
        }

    def getSections(self):
        '''
        Define all the sections in a sample
        '''
        sections = []
        for sec in self.pe.sections:
            sections.append(Section(name=sec.Name.decode().strip('\x00'), sample=self, start=(sec.VirtualAddress + self.min_address),
                            size=sec.SizeOfRawData, exe=sec.__dict__['IMAGE_SCN_MEM_EXECUTE'], sha256=sec.get_hash_sha256()))
        self.pe.close()
        return sections

    def find_section(self, address):
        '''
        Find the section containing the address
        '''
        for sec in self.sections:
            if sec.contain(address):
                return sec
        return None

    def json_sections(self):
        '''
        Create json file for the sections
        '''
        # json_string = json.dumps(
        #     self.sections[0], indent=4, cls=SectionEncoder)
        # print(json_string)
        with open("outputs/" + self.name + ".json", 'w') as file:
            json.dump(self, file, indent=4, cls=SectionEncoder)

    def trace_and_nucleus(self):
        '''
        Add executed instructions and run Nucleus tool to get the functions
        '''
        addr_to_visit = []
        # Instruction executed
        for addr in self.trace:
            addr_to_visit.append(toAddr(addr).getOffset())
        # Nucleus
        command = "nucleus/nucleus -t dmp -a x86 -l 32 -e " + \
            self.dmp_file + " -d linear -f"
        try:
            result = subprocess.run(command, shell=True,
                                    check=True, capture_output=True, text=True)
        except:
            print("->\tNucleus can't analyze this file")
            raise Exception
        for entry in result.stdout.splitlines():
            address = re.findall('0x.{16}', entry)
            addr = toAddr(''.join(address))
            addr_to_visit.append(addr.getOffset())
        return addr_to_visit

    def parse_trace(self):
        bbl_string = open(self.bbl_file).read()
        bbl_list = re.findall('.{1,8}', bbl_string)
        return bbl_list

    def self_modifying(self):
        if hasattr(self.pe, 'DIRECTORY_ENTRY_BASERELOC'):
            # reloc entries
            reloc_table = self.pe.DIRECTORY_ENTRY_BASERELOC
            tmp = []
            text_sec = self.sections[0]
            for reloc_entry in reloc_table:
                # `text_sec.end - self.min_address` is used to find the relative end of .text section
                if reloc_entry.struct.VirtualAddress >= text_sec.end - self.min_address:
                    break
                for reloc_data in reloc_entry.entries:
                    tmp.append(reloc_data.rva)
            # dmp .text section
            bytes = bytearray()
            byte_array = getBytes(toAddr(text_sec.start), text_sec.size)
            for byte in byte_array:
                if byte < 0:
                    byte = 0x100 + int(hex(byte), 16)
                bytes.append(byte)
            # byte to change
            byte_to_change = (self.min_address >> 16) & 0xff
            # takes reloc table addresses and convert the corresponding bytes
            for addr in tmp:
                # since the reloc table starts at the beg of pe
                # but the bytearray starts at the beg of the .text section there is an offset, usually 0x1000
                offset = text_sec.start - self.min_address
                if bytes[addr + 2 - offset] == byte_to_change:
                    bytes[addr + 2 - offset] = 0x40
                # else:
                #     print(hex(0xc20000+addr+2))
            # calculate and compare hashes
            sha256_hash_dmp = sha256(bytes).hexdigest()
            sha256_hash_pe = text_sec.sha256
            if sha256_hash_pe == sha256_hash_dmp:
                return False
            else:
                return True
        else:
            print("No relocation table found in the PE file")
            return None


def bytesToAddr(bytes):
    b_list = []
    for byte in bytes:
        if byte < 0:
            byte = 0x100 + int(hex(byte), 16)
        b_list.insert(0, byte)
    hex_address = "0x" + "".join(format(b, '02x') for b in b_list)
    return hex_address


def checkIndirectBlocks(bb_addr):
    '''
    Check all the indirect calls
    '''
    inst = getInstructionAt(bb_addr)
    ext_in_bb = []
    while True:
        # Continue for all the basic block
        if inst == None or sample.bbm.getFirstCodeBlockContaining(inst.getInstructionContext().getAddress(), monitor).getFirstStartAddress() != bb_addr:
            break
        matches = re.findall(r'0x\w{1,8}', inst.toString())
        if len(matches) > 0:
            addr = toAddr(matches[0])
            if addr.getOffset() > sample.min_address and addr.getOffset() < sample.max_address:
                match = re.match(r'CALL .*\[(0x.{1,8})\]', inst.toString())
                if match:
                    # Indirect address
                    hex_address = bytesToAddr(getBytes(addr, 4))
                    sample.addr_to_visit.insert(
                        0, toAddr(hex_address).getOffset())

                    if match.group(1)[2:] in sample.externals:
                        ext_in_bb.append(sample.externals[match.group(1)[2:]])
                else:
                    # Direct address
                    sample.addr_to_visit.insert(0, addr.getOffset())
        inst = inst.getNext()
    if ext_in_bb:
        sample.ext_cover[bb_addr.toString()] = ext_in_bb


def bb_disassembled_ratio():
    '''
    Compute the disassembled ratio for the executable addresses
    '''
    unknown_sec = set()
    used_addresses = set()
    for node in G.nodes():
        section = sample.find_section(toAddr(int(node, 16)).getOffset())
        if section != None:
            section.bbs += 1
        else:
            # TODO quando non è di nessuna section bisogna trovare il bb quindi magari getCodeBlockContaining
            bb = sample.bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
            if bb != None:
                unknown_sec.add(hex(bb.getFirstStartAddress().getOffset()))
            continue
        bb = sample.bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
        if bb != None:
            if section.size > 0x0:
                if bb.getMinAddress().getOffset() > section.start and bb.getMaxAddress().getOffset() < section.end:
                    start = max(bb.getMinAddress().getOffset(), section.start)
                    end = min(bb.getMaxAddress().getOffset(), section.end)
                    if end >= start:
                        slot = 0
                        # Check if any address within the range is already used
                        for address in range(start, end + 1):
                            if address in used_addresses:
                                continue
                            # Update the used addresses
                            else:
                                slot += 1
                                used_addresses.add(address)
                        section.disass += slot
    for section in sample.sections:
        if section.size > 0:
            section.disass = section.disass / section.size
        else:
            section.disass = 0.0
    sample.unknown_sec = sorted(unknown_sec)


def bb_coverage():
    '''
    Compute the executed bbs based on the trace file
    '''
    for addr in sample.trace:
        bb = sample.bbm.getFirstCodeBlockContaining(toAddr(addr), monitor)
        if bb != None:
            section = sample.find_section(
                bb.getFirstStartAddress().getOffset())
            if G.has_node(bb.getFirstStartAddress().toString()):
                sample.bb_exe.add(bb.getFirstStartAddress().toString())
                section.coverage += 1
            elif bb.getFirstStartAddress().toString() != "00000000":
                section.not_seen_set.add(
                    hex(bb.getFirstStartAddress().getOffset()))
    for sec in sample.sections:
        sec.not_seen = sorted(sec.not_seen_set)
        if sec.bbs > 0:
            sec.coverage = sec.coverage / sec.bbs
        else:
            sec.coverage = 0.0


def bb_functions():
    '''
    Compute all stats on bbs and api for each function
    '''
    # Count bb disassembled
    for node in G.nodes():
        sec = sample.find_section(toAddr(int(node, 16)).getOffset())
        if sec == None:
            continue
        # Take functions existent
        f = getFunctionContaining(toAddr(node))
        if f == None:
            # Or create them
            f = createFunction(toAddr(node), "FUN_"+toAddr(node).toString())
        if f != None and f.toString() in sec.functions:
            sec.functions[f.toString()].tot_bb += 1
            if node in sample.ext_cover:
                sec.functions[f.toString(
                )].tot_api += len(sample.ext_cover[node])
                # Put in the list all the api for that function
                sec.functions[f.toString()].api_not_executed.extend(
                    sample.ext_cover[node])
    # Count bb executed
    for bb in sample.bb_exe:
        sec = sample.find_section(toAddr(bb).getOffset())
        if sec == None:
            continue
        f = getFunctionContaining(toAddr(bb))
        if f == None:
            f = createFunction(toAddr(bb), "FUN_"+toAddr(bb).toString())
        if f != None and f.toString() in sec.functions:
            sec.functions[f.toString()].exe_bb += 1
            if bb in sample.ext_cover:
                sec.functions[f.toString(
                )].exe_api += len(sample.ext_cover[bb])
                # Remove the api called
                for api in sample.ext_cover[bb]:
                    if api in sec.functions[f.toString()].api_not_executed:
                        sec.functions[f.toString()].api_not_executed.remove(
                            api)


def basic_block(address):
    '''
    Analyze a single basic block
    '''
    disassemble(address)
    # TODO disass solo se non c'è istruzione; disass le funzioni con la size corretta
    bb = sample.bbm.getFirstCodeBlockContaining(address, monitor)
    if bb != None:
        G.add_node(bb.getFirstStartAddress().toString(), color="blue")
        # Check if there are other possible functions not called directly
        checkIndirectBlocks(bb.getFirstStartAddress())
        dests = bb.getDestinations(monitor)
        while (dests.hasNext()):
            dbb = dests.next()
            # Add adresses to the list
            if dbb != None:
                sample.addr_to_visit.insert(0, dbb.getReference().getOffset())
                # Create the node for the basic block and link
                G.add_node(dbb.getReference().toString(), color="blue")
                print("\t[*] {} -> {}".format(bb.getFirstStartAddress(),
                      dbb.getReference()), file=log)
                G.add_edge(bb.getFirstStartAddress().toString(),
                           dbb.getReference().toString(), color="black")


def main():
    while len(sample.addr_to_visit) > 0:
        addr = sample.addr_to_visit.pop()
        if not addr in sample.addr_visited:
            basic_block(toAddr(addr))
            sample.addr_visited.append(addr)
    # Export the graph
    with open('graph.pickle', 'wb') as file:
        pickle.dump(G, file)
    # Stats
    bb_disassembled_ratio()
    bb_coverage()
    bb_functions()


# Starts execution here
if __name__ == "__main__":
    print("Start")

    G = nx.Graph()
    monitor = getMonitor()
    # Sample
    sample = Sample(str(getProgramFile()))
    # Main program
    log = open("log.txt", "w")
    main()
    log.close()
    # Print
    print(sample)
    sample.json_sections()

    print("End")
