import pefile
import subprocess
import pickle
import networkx as nx
import re
import os
import json
from json import JSONEncoder
from hashlib import sha256
from minidump import minidumpfile
from ghidra.program.model.block import BasicBlockModel


class SectionEncoder(JSONEncoder):
    def default(self, o):
        return o.__dict__()


class Function:
    def __init__(self, name):
        self.name = name
        self.exe_bb = 0
        self.tot_bb = 0
        self.exe_api = 0
        self.tot_api = 0
        self.api_not_executed = []

    def __dict__(self):
        return {
            "name": self.name,
            "exe_bb": self.exe_bb,
            "tot_bb": self.tot_bb,
            "exe_api": self.exe_api,
            "tot_api": self.tot_api,
            "api_not_executed": self.api_not_executed
        }


class Heap:
    index = 1

    def __init__(self,  start, end):
        self.name = "heap" + str(Heap.index)
        self.start = start
        self.size = end-start
        self.end = end
        self.instr_disass = 0
        self.instr_exec = 0
        self.ratio = 0.0
        Heap.index += 1

    def __str__(self):
        return f"Heap: {self.name}\nStart: {hex(self.start)}\nSize: {hex(self.size)}\nEnd: {hex(self.end)}\n"

    def __dict__(self):
        return {
            "name": self.name,
            "start": hex(self.start),
            "size": hex(self.size),
            "end": hex(self.end),
            "instr_exec": self.instr_exec,
            "instr_disass": self.instr_disass,
            "ratio": self.ratio,
        }

    def contains(self, address):
        if address >= self.start and address <= self.end:
            return True
        return False


class Module:
    def __init__(self, name, start, end):
        self.name = name
        self.start = start
        self.size = end - start
        self.end = end
        self.instr_exec = 0

    def __dict__(self):
        return {
            "name": self.name,
            "start": hex(self.start),
            "size": hex(self.size),
            "end": hex(self.end),
            "instr_exec": self.instr_exec
        }

    def contains(self, address):
        if address >= self.start and address <= self.end:
            return True
        return False


class Section:
    def __init__(self, name, sample, start, size, exe, sha256):
        self.name = name
        self.sample = sample
        self.start = start
        self.size = size
        self.end = start+size
        self.executable_flag = exe
        self.sha256 = sha256
        self.disass = 0.0
        self.bbs = 0
        self.coverage = 0.0
        self.not_seen = []
        self.not_seen_set = set()
        self.functions = {}

    def __str__(self):
        return f"Section: {self.name}\nStart: {hex(self.start)}\nSize: {hex(self.size)}\nEnd: {hex(self.end)}\nExecutable: {self.executable_flag}\n\nDisassembly ratio: {self.disass:.4f}\nCoverage: {self.coverage:.4f}\nBBs executed but not found: {self.not_seen}\n\n"

    def __dict__(self):
        return {
            "name": self.name,
            "start": hex(self.start),
            "size": hex(self.size),
            "end": hex(self.end),
            "executable": self.executable_flag,
            "sha256": self.sha256,
            "disassembly_ratio": self.disass,
            "coverage": self.coverage,
            "bbs_not_executed": self.not_seen,
            "functions": list(self.functions.values())
        }

    def functions_dict(self):
        # Create function dictionary
        if self.executable_flag:
            for addr in self.sample.addr_to_visit:
                if self.contains(addr):
                    addr = toAddr(addr)
                    func = getFunctionContaining(addr)
                    if func == None:
                        func = createFunction(addr, "FUN_"+addr.toString())
                    if func != None:
                        self.functions[func.toString()] = Function(
                            func.toString())

    def contains(self, address):
        if address >= self.start and address <= self.end:
            return True
        return False


class Sample:
    def __init__(self, dmp_file):
        self.dmp_file = dmp_file
        self.sample_file = self.dmp_file.split(".")[0]
        self.name = currentProgram.getName().split(".")[0]
        self.bbl_file = self.dmp_file[:-3]+"bbl"
        self.min_address = currentProgram.getMinAddress().getOffset()
        self.max_address = currentProgram.getMaxAddress().getOffset()
        # PE file
        self.pe = pefile.PE(self.sample_file)
        # dmp file
        self.minidump = minidumpfile.MinidumpFile.parse(self.sample_file)
        # BasicBlockModel
        self.bbm = BasicBlockModel(currentProgram)
        # Instruction trace
        self.trace = self.parse_trace()
        # Addresses
        self.addr_to_visit = self.trace_and_nucleus()
        self.addr_visited = [0x000000]
        # Get sections
        self.sections = self.getSections()
        # Get modules (of the dmp)
        self.modules = self.getModules()
        # Get heaps
        self.heaps = self.getHeap()
        # Self modifying code
        self.modified = self.self_modifying()
        # External function dictionary(s)
        try:
            with open("externals.pickle", "rb") as file:
                self.externals = pickle.load(file)
        except:
            print("->\tfile .pickle not found")
            raise Exception
        self.ext_cover = {}
        # Set for executed bbs
        self.bb_exe = set()
        # Function and API dicts
        for sec in self.sections:
            sec.functions_dict()
        # Executed address, not disass, from no sections
        self.unknown_instr = []

    def __str__(self):
        return f"Analyzed {self.name}"

    def __dict__(self):
        return {
            "sample_name": self.name,
            "modifying .text section": self.modified,
            "ext_instr": {"modules": self.modules, "unknown_instr": self.unknown_instr},
            "heaps": self.heaps,
            "sections": self.sections
        }

    def getSections(self):
        '''
        Define all the sections in a sample
        '''
        sections = []
        for sec in self.pe.sections:
            sections.append(Section(name=sec.Name.decode().strip('\x00'), sample=self, start=(sec.VirtualAddress + self.min_address),
                            size=sec.SizeOfRawData, exe=sec.__dict__['IMAGE_SCN_MEM_EXECUTE'], sha256=sec.get_hash_sha256()))
        self.pe.close()
        return sections

    def getModules(self):
        '''
        Define all the modules
        '''
        modules = []
        for module in self.minidump.modules.modules:
            modules.append(
                Module(name=module.name, start=module.baseaddress, end=module.endaddress))
        return modules

    def getHeap(self):
        '''
        Define heaps
        '''
        heaps = []
        pattern = r"Segment at ([0-9a-fA-F]+) to ([0-9a-fA-F]+)"
        command = 'echo !heap -a;q | "C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\kd.exe" -y srv* -z ' + self.dmp_file
        try:
            result = subprocess.run(
                command, shell=True, check=True, capture_output=True, text=True)
        except Exception as e:
            print("*\tWinDbg can't analyze the heap -> " + e)
        for line in result.stdout.splitlines():
            match = re.search(pattern, line)
            if match:
                heaps.append(Heap(int(match.group(1), 16),
                             int(match.group(2), 16)))
        return heaps

    def find_section(self, address):
        '''
        Find the section containing the address
        '''
        for sec in self.sections:
            if sec.contains(address):
                return sec
        return None

    def json_sections(self):
        '''
        Create json file for the sections
        '''
        # json_string = json.dumps(
        #     self.sections[0], indent=4, cls=SectionEncoder)
        # print(json_string)
        with open("outputs/" + self.name + ".json", 'w') as file:
            json.dump(self, file, indent=4, cls=SectionEncoder)

    def trace_and_nucleus(self):
        '''
        Add executed instructions and run Nucleus tool to get the functions
        '''
        addr_to_visit = []
        # Instruction executed
        for addr in self.trace:
            addr_to_visit.append(toAddr(addr).getOffset())
        # Nucleus
        os.system(
            'wsl nucleus/nucleus -t dmp -a x86 -l 32 -e ' + self.dmp_file + ' -d linear -f > nucleus.txt')
        with open("nucleus.txt", "r") as file:
            for entry in file.readlines():
                address = re.findall('0x.{16}', entry)
                addr = toAddr(''.join(address))
                addr_to_visit.append(addr.getOffset())
        os.remove("nucleus.txt")
        return addr_to_visit

    def parse_trace(self):
        bbl_string = open(self.bbl_file).read()
        bbl_list = re.findall('.{1,8}', bbl_string)
        return [int(addr, 16) for addr in bbl_list]

    def self_modifying(self):
        if hasattr(self.pe, 'DIRECTORY_ENTRY_BASERELOC'):
            # reloc entries
            reloc_table = self.pe.DIRECTORY_ENTRY_BASERELOC
            tmp = []
            text_sec = self.sections[0]
            for reloc_entry in reloc_table:
                # `text_sec.end - self.min_address` is used to find the relative end of .text section
                if reloc_entry.struct.VirtualAddress >= text_sec.end - self.min_address:
                    break
                for reloc_data in reloc_entry.entries:
                    tmp.append(reloc_data.rva)
            # dmp .text section
            bytes = bytearray()
            byte_array = getBytes(toAddr(text_sec.start), text_sec.size)
            for byte in byte_array:
                if byte < 0:
                    byte = 0x100 + int(hex(byte), 16)
                bytes.append(byte)
            # byte to change
            byte_to_change = (self.min_address >> 16) & 0xff
            # takes reloc table addresses and convert the corresponding bytes
            for addr in tmp:
                # since the reloc table starts at the beg of pe
                # but the bytearray starts at the beg of the .text section there is an offset, usually 0x1000
                offset = text_sec.start - self.min_address
                if bytes[addr + 2 - offset] == byte_to_change:
                    bytes[addr + 2 - offset] = 0x40
                # else:
                #     print(hex(0xc20000+addr+2))
            # calculate and compare hashes
            sha256_hash_dmp = sha256(bytes).hexdigest()
            sha256_hash_pe = text_sec.sha256
            if sha256_hash_pe == sha256_hash_dmp:
                return False
            else:
                return True
        else:
            print("No relocation table found in the PE file")
            return None


def bytesToAddr(bytes):
    b_list = []
    for byte in bytes:
        if byte < 0:
            byte = 0x100 + int(hex(byte), 16)
        b_list.insert(0, byte)
    hex_address = "0x" + "".join(format(b, '02x') for b in b_list)
    return hex_address


def checkIndirectBlocks(bb_addr):
    '''
    Check all the indirect calls
    '''
    inst = getInstructionAt(bb_addr)
    ext_in_bb = []
    while True:
        # Continue for all the basic block
        if inst == None or sample.bbm.getFirstCodeBlockContaining(inst.getInstructionContext().getAddress(), monitor).getFirstStartAddress() != bb_addr:
            break
        matches = re.findall(r'0x\w{1,8}', inst.toString())
        if len(matches) > 0:
            addr = toAddr(matches[0])
            if addr.getOffset() > sample.min_address and addr.getOffset() < sample.max_address:
                match = re.match(r'CALL .*\[(0x.{1,8})\]', inst.toString())
                if match:
                    # Indirect address
                    hex_address = bytesToAddr(getBytes(addr, 4))
                    sample.addr_to_visit.insert(
                        0, toAddr(hex_address).getOffset())

                    if match.group(1)[2:] in sample.externals:
                        ext_in_bb.append(sample.externals[match.group(1)[2:]])
                else:
                    # Direct address
                    sample.addr_to_visit.insert(0, addr.getOffset())
        inst = inst.getNext()
    if ext_in_bb:
        sample.ext_cover[bb_addr.toString()] = ext_in_bb


def bb_disassembled_ratio():
    '''
    Compute the disassembled ratio for the executable addresses
    '''
    used_addresses = set()
    for node in G.nodes():
        section = sample.find_section(toAddr(int(node, 16)).getOffset())
        if section != None:
            section.bbs += 1
        else:
            # TODO quando non è di nessuna section bisogna trovare il bb quindi magari getCodeBlockContaining
            # There is a proper func for instr in no sec
            continue
        bb = sample.bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
        if bb != None:
            if section.size > 0x0:
                if bb.getMinAddress().getOffset() > section.start and bb.getMaxAddress().getOffset() < section.end:
                    start = max(bb.getMinAddress().getOffset(), section.start)
                    end = min(bb.getMaxAddress().getOffset(), section.end)
                    if end >= start:
                        slot = 0
                        # Check if any address within the range is already used
                        for address in range(start, end + 1):
                            if address in used_addresses:
                                continue
                            # Update the used addresses
                            else:
                                slot += 1
                                used_addresses.add(address)
                        section.disass += slot
    for section in sample.sections:
        # remove 0x00 bytes
        zero_bytes = 0
        for addr in range(section.start, section.end):
            if not addr in used_addresses and getByte(toAddr(addr)) == 0:
                zero_bytes += 1
        # calculate the ratio
        if section.size > 0 and section.disass > 0:
            section.disass = (section.disass + zero_bytes) / section.size
        else:
            section.disass = 0.0


def bb_coverage():
    '''
    Compute the executed bbs based on the trace file
    '''
    for addr in sample.trace:
        bb = sample.bbm.getFirstCodeBlockContaining(toAddr(addr), monitor)
        if bb != None:
            section = sample.find_section(
                bb.getFirstStartAddress().getOffset())
            if G.has_node(bb.getFirstStartAddress().toString()):
                sample.bb_exe.add(bb.getFirstStartAddress().toString())
                section.coverage += 1
            elif bb.getFirstStartAddress().toString() != "00000000":
                section.not_seen_set.add(
                    hex(bb.getFirstStartAddress().getOffset()))
    for sec in sample.sections:
        sec.not_seen = sorted(sec.not_seen_set)
        if sec.bbs > 0:
            sec.coverage = sec.coverage / sec.bbs
        else:
            sec.coverage = 0.0


def bb_functions():
    '''
    Compute all stats on bbs and api for each function
    '''
    # Count bb disassembled
    for node in G.nodes():
        sec = sample.find_section(toAddr(int(node, 16)).getOffset())
        if sec == None:
            continue
        # Take functions existent
        f = getFunctionContaining(toAddr(node))
        if f == None:
            # Or create them
            f = createFunction(toAddr(node), "FUN_"+toAddr(node).toString())
        if f != None and f.toString() in sec.functions:
            sec.functions[f.toString()].tot_bb += 1
            if node in sample.ext_cover:
                sec.functions[f.toString(
                )].tot_api += len(sample.ext_cover[node])
                # Put in the list all the api for that function
                sec.functions[f.toString()].api_not_executed.extend(
                    sample.ext_cover[node])
    # Count bb executed
    for bb in sample.bb_exe:
        sec = sample.find_section(toAddr(bb).getOffset())
        if sec == None:
            continue
        f = getFunctionContaining(toAddr(bb))
        if f == None:
            f = createFunction(toAddr(bb), "FUN_"+toAddr(bb).toString())
        if f != None and f.toString() in sec.functions:
            sec.functions[f.toString()].exe_bb += 1
            if bb in sample.ext_cover:
                sec.functions[f.toString(
                )].exe_api += len(sample.ext_cover[bb])
                # Remove the api called
                for api in sample.ext_cover[bb]:
                    if api in sec.functions[f.toString()].api_not_executed:
                        sec.functions[f.toString()].api_not_executed.remove(
                            api)


def heap_coverage():
    for addr in sample.trace:
        for heap in sample.heaps:
            if heap.contains(addr):
                heap.instr_exec += 1
    # TODO add heap disass
    for heap in sample.heaps:
        if heap.instr_disass > 0 and heap.instr_exec > 0:
            heap.ratio = heap.instr_exec / heap.instr_disass


def instr_coverage():
    contained = False
    unknown_instr_set = set()
    for addr in sample.trace:
        # Sections
        for sec in sample.sections:
            if sec.contains(addr):
                contained = True
        # Heaps
        for heap in sample.heaps:
            if heap.contains(addr):
                contained = True
        # Modules
        for module in sample.modules:
            if module.contains(addr):
                module.instr_exec += 1
                contained = True
        # Unknown
        if not contained and addr != 0x0:
            unknown_instr_set.add(hex(addr))
        else:
            contained = False
    sample.unknown_instr = sorted(unknown_instr_set)


def basic_block(address):
    '''
    Analyze a single basic block
    '''
    if getInstructionContaining(address) == None:
        disassemble(address)
    bb = sample.bbm.getFirstCodeBlockContaining(address, monitor)
    if bb != None:
        G.add_node(bb.getFirstStartAddress().toString(), color="blue")
        # Check if there are other possible functions not called directly
        checkIndirectBlocks(bb.getFirstStartAddress())
        dests = bb.getDestinations(monitor)
        while (dests.hasNext()):
            dbb = dests.next()
            # Add adresses to the list
            if dbb != None:
                sample.addr_to_visit.insert(0, dbb.getReference().getOffset())
                # Create the node for the basic block and link
                G.add_node(dbb.getReference().toString(), color="blue")
                print("\t[*] {" + bb.getFirstStartAddress().toString() +
                      "} ->{" + dbb.getReference().toString() + "}", file=log)
                G.add_edge(bb.getFirstStartAddress().toString(),
                           dbb.getReference().toString(), color="black")


def main():
    while len(sample.addr_to_visit) > 0:
        addr = sample.addr_to_visit.pop()
        if not addr in sample.addr_visited:
            basic_block(toAddr(addr))
            sample.addr_visited.append(addr)
    # Export the graph
    with open('graph.pickle', 'wb') as file:
        pickle.dump(G, file)
    # Stats
    bb_disassembled_ratio()
    bb_coverage()
    bb_functions()
    heap_coverage()
    instr_coverage()


# Starts execution here
if __name__ == "__main__":
    print("Start")

    G = nx.Graph()
    monitor = getMonitor()
    # Sample
    sample = Sample(str(getProgramFile()))
    # Main program
    log = open("log.txt", "w")
    main()
    log.close()
    # Print
    print(sample)
    sample.json_sections()

    print("End")
