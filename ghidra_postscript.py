import os
import pickle
import re
from classes.sample import Sample
from ghidra.program.disassemble import Disassembler


def bytes_to_addr(bytes):
    b_list = []
    for byte in bytes:
        if byte < 0:
            byte = 0x100 + int(hex(byte), 16)
        b_list.insert(0, byte)
    hex_address = "0x" + "".join(format(b, '02x') for b in b_list)
    return hex_address


def check_indirect_blocks(bb_addr):
    '''
    Check all the indirect calls
    '''
    inst = getInstructionAt(bb_addr)
    ext_in_bb = []
    while True:
        # Continue for all the basic block
        if inst == None or sample.bbm.getFirstCodeBlockContaining(inst.getInstructionContext().getAddress(), monitor).getFirstStartAddress() != bb_addr:
            break
        matches = re.findall(r'0x\w{1,8}', inst.toString())
        if len(matches) > 0:
            addr = toAddr(matches[0])
            if addr.getOffset() > sample.min_address and addr.getOffset() < sample.max_address:
                match = re.match(r'CALL .*\[(0x.{1,8})\]', inst.toString())
                if match:
                    # Indirect address
                    hex_address = bytes_to_addr(getBytes(addr, 4))
                    sample.addr_to_visit.insert(
                        0, toAddr(hex_address).getOffset())

                    if sample.externals and match.group(1)[2:] in sample.externals:
                        ext_in_bb.append(sample.externals[match.group(1)[2:]])
                else:
                    # Direct address
                    sample.addr_to_visit.insert(0, addr.getOffset())
        inst = inst.getNext()
    if ext_in_bb:
        sample.ext_cover[bb_addr.toString()] = ext_in_bb


def bb_disassembled_ratio():
    '''
    Compute the disassembled ratio for the executable addresses
    '''
    used_addresses = set()
    for node in sample.G.nodes():
        section = sample.find_section(node)
        if section != None:
            section.bbs += 1
        else:
            # Bbs visited but they don't have a section (already considered in modules)
            continue
        bb = sample.bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
        if bb != None:
            if section.size > 0x0:
                if bb.getMinAddress().getOffset() > section.start and bb.getMaxAddress().getOffset() < section.end:
                    start = max(bb.getMinAddress().getOffset(), section.start)
                    end = min(bb.getMaxAddress().getOffset(), section.end)
                    if end >= start:
                        slot = 0
                        # Check if any address within the range is already used
                        for address in range(start, end + 1):
                            if address in used_addresses:
                                continue
                            # Update the used addresses
                            else:
                                slot += 1
                                used_addresses.add(address)
                        section.disass += slot
    for section in sample.sections:
        # remove 0x00 bytes
        zero_bytes = 0
        for addr in range(section.start, section.end):
            if not addr in used_addresses and getByte(toAddr(addr)) == 0:
                zero_bytes += 1
        # calculate the ratio
        if section.size > 0 and section.disass > 0:
            section.disass = (
                (section.disass + zero_bytes) / section.size) * 100
        else:
            section.disass = None


def bb_coverage():
    '''
    Compute the executed bbs based on the trace file
    '''
    for addr in sample.trace:
        bb = sample.bbm.getFirstCodeBlockContaining(toAddr(addr), monitor)
        if bb != None:
            # Get all the bbs executed per sample
            section = sample.find_section(
                bb.getFirstStartAddress().toString())
            if section and sample.G.has_node(bb.getFirstStartAddress().toString()):
                if not bb.getFirstStartAddress().toString() in sample.bb_exe:
                    section.coverage += 1
                sample.bb_exe.add(bb.getFirstStartAddress().toString())
                # Get all the bbs executed per function
                function = sample.find_function(
                    bb.getFirstStartAddress().getOffset())
                if function:
                    function.bb_exe_set.add(
                        bb.getFirstStartAddress().toString())
            # Basic blocks not visited but executed
            # SHOULD BE EMPTY
            elif section and bb.getFirstStartAddress().toString() != "00000000":
                section.not_seen_set.add(
                    hex(bb.getFirstStartAddress().getOffset()))
            # Basic blocks not in sections (SHOULD be impossible)
            # elif not section:
            #    print(bb.getFirstStartAddress().toString())
    for sec in sample.sections:
        sec.not_seen = sorted(sec.not_seen_set)
        if sec.bbs > 0 and sec.coverage > 0:
            sec.coverage = (sec.coverage / sec.bbs) * 100
        else:
            sec.coverage = None


def bb_functions():
    '''
    Compute all stats on bbs and api for each function
    '''
    # Count bb disassembled
    for node in sample.G.nodes():
        sec = sample.find_section(node)
        if sec == None:
            continue
        # Find functions
        function = sample.find_function(node)
        if function:
            function.bb_tot += 1
            if node in sample.ext_cover:
                function.api_tot += len(sample.ext_cover[node])
                # Put in the list all the api for that function
                function.api_not_executed.extend(sample.ext_cover[node])
    # Count bb executed
    for bb in sample.bb_exe:
        sec = sample.find_section(bb)
        if sec == None:
            continue
        # Find functions
        function = sample.find_function(bb)
        if function:
            function.bb_exe += 1
            if bb in sample.ext_cover:
                function.api_exe += len(sample.ext_cover[bb])
                # Remove the api called
                for api in sample.ext_cover[bb]:
                    if api in function.api_not_executed:
                        function.api_not_executed.remove(api)


def heap_coverage():
    file_name = "heap.bytes"
    for addr in sample.trace:
        for heap in sample.heaps:
            if heap.contains(addr):
                heap.instr_exe += 1
                heap.instr_list.append(hex(addr))
    for heap in sample.heaps:
        with open(sample.dmp_file, 'rb') as source_file:
            source_file.seek(heap.offset)
            with open(file_name, 'wb') as destination_file:
                data = source_file.read(heap.size)
                destination_file.write(data)
        heap_prog = importFileAsBinary(parseFile(
            file_name), currentProgram.getLanguage(), currentProgram.getCompilerSpec())
        openProgram(heap_prog)

        # Start of transaction
        id = heap_prog.startTransaction(heap.name + " analysis")
        heap_prog.setImageBase(toAddr(heap.start), True)
        disassembler = Disassembler.getDisassembler(heap_prog, monitor, None)
        if len(heap.instr_list) > 0:
            for heap_instr in heap.instr_list:
                disassembler.disassemble(toAddr(heap_instr), None, True)
        # End of transaction
        heap_prog.endTransaction(id, True)

        for _ in heap_prog.getListing().getInstructions(True):
            heap.instr_tot += 1
        if heap.instr_exe > 0 and heap.instr_tot > 0:
            heap.instr_cov = (heap.instr_exe / heap.instr_tot) * 100
        else:
            heap.instr_cov = None
        if heap.instr_tot > 0 and heap.size > 0:
            heap.size_cov = (heap.instr_tot / heap.size) * 100
        else:
            heap.size_cov = None
    if os.path.isfile(file_name):
        os.remove(file_name)


def instr_coverage():
    contained = False
    unknown_instr_set = set()
    for addr in sample.trace:
        # Sections
        for sec in sample.sections:
            if sec.contains(addr):
                contained = True
        # Heaps
        for heap in sample.heaps:
            if heap.contains(addr):
                contained = True
        # Modules
        for module in sample.modules:
            if module.contains(addr):
                module.instr_tot += 1
                contained = True
        # Unknown
        if not contained and addr != 0x0:
            unknown_instr_set.add(hex(addr))
        else:
            contained = False
    sample.unknown_instr = sorted(unknown_instr_set)


def edge_coverage():
    # Get the executed function graph (subset)
    subgraph = sample.G.subgraph(sample.bb_exe)
    sample.edge_exe = len(subgraph.edges())
    sample.edge_tot = len(sample.G.edges())
    if sample.edge_exe > 0 and sample.edge_tot > 0:
        sample.edge_cov = (sample.edge_exe / sample.edge_tot) * 100
    else:
        sample.edge_cov = None
    # Edge coverage for functions
    for sec in sample.sections:
        for function in sec.functions.values():
            # Get the function graph
            function.graph = sample.G.subgraph(function.bb_set)
            # Get the executed function graph (subset)
            subgraph = function.graph.subgraph(function.bb_exe_set)
            function.edge_exe = len(subgraph.edges())
            function.edge_tot = len(function.graph.edges())
            if function.edge_exe > 0 and function.edge_tot > 0:
                function.edge_cov = (function.edge_exe /
                                     function.edge_tot) * 100
            else:
                function.edge_cov = None


def basic_block(address):
    '''
    Analyze a single basic block
    '''
    if getInstructionContaining(address) == None:
        disassemble(address)
    bb = sample.bbm.getFirstCodeBlockContaining(address, monitor)
    if bb != None:
        node1 = bb.getFirstStartAddress()
        sample.G.add_node(node1.toString())
        # Check if there are other possible functions not called directly
        check_indirect_blocks(node1)
        # Get visited bb of a function
        func = sample.find_function(address.getOffset())
        if func:
            func.bb_set.add(bb.getFirstStartAddress().toString())
        # Get destinations
        dests = bb.getDestinations(monitor)
        while (dests.hasNext()):
            dbb = dests.next()
            # Add adresses to the list
            if dbb != None:
                node2 = dbb.getReference()
                sample.addr_to_visit.insert(0, node2.getOffset())
                # Create the edge
                print("\t[*] {" + node1.toString() + "} ->{" +
                      node2.toString() + "}", file=log)
                sample.G.add_edge(node1.toString(), node2.toString())


def main():
    while len(sample.addr_to_visit) > 0:
        addr = sample.addr_to_visit.pop()
        if not addr in sample.addr_visited:
            basic_block(toAddr(addr))
            sample.addr_visited.append(addr)
    # Export the graph
    with open('graph.pickle', 'wb') as file:
        pickle.dump(sample.G, file)
    # Stats
    bb_disassembled_ratio()
    bb_coverage()
    bb_functions()
    heap_coverage()
    instr_coverage()
    edge_coverage()


# Starts execution here
if __name__ == "__main__":
    print("Start")

    monitor = getMonitor()
    # Sample
    sample = Sample(str(getProgramFile()))
    # Main program
    log = open("log.txt", "w")
    main()
    log.close()
    # Print
    print(sample)
    sample.json_sections()

    print("End")
