import pickle
import networkx as nx
import re
from classes.sample import Sample


def bytesToAddr(bytes):
    b_list = []
    for byte in bytes:
        if byte < 0:
            byte = 0x100 + int(hex(byte), 16)
        b_list.insert(0, byte)
    hex_address = "0x" + "".join(format(b, '02x') for b in b_list)
    return hex_address


def checkIndirectBlocks(bb_addr):
    '''
    Check all the indirect calls
    '''
    inst = getInstructionAt(bb_addr)
    ext_in_bb = []
    while True:
        # Continue for all the basic block
        if inst == None or sample.bbm.getFirstCodeBlockContaining(inst.getInstructionContext().getAddress(), monitor).getFirstStartAddress() != bb_addr:
            break
        matches = re.findall(r'0x\w{1,8}', inst.toString())
        if len(matches) > 0:
            addr = toAddr(matches[0])
            if addr.getOffset() > sample.min_address and addr.getOffset() < sample.max_address:
                match = re.match(r'CALL .*\[(0x.{1,8})\]', inst.toString())
                if match:
                    # Indirect address
                    hex_address = bytesToAddr(getBytes(addr, 4))
                    sample.addr_to_visit.insert(
                        0, toAddr(hex_address).getOffset())

                    if match.group(1)[2:] in sample.externals:
                        ext_in_bb.append(sample.externals[match.group(1)[2:]])
                else:
                    # Direct address
                    sample.addr_to_visit.insert(0, addr.getOffset())
        inst = inst.getNext()
    if ext_in_bb:
        sample.ext_cover[bb_addr.toString()] = ext_in_bb


def bb_disassembled_ratio():
    '''
    Compute the disassembled ratio for the executable addresses
    '''
    used_addresses = set()
    for node in G.nodes():
        section = sample.find_section(node)
        if section != None:
            section.bbs += 1
        else:
            # TODO quando non Ã¨ di nessuna section bisogna trovare il bb quindi magari getCodeBlockContaining
            # There is a proper func for instr in no sec
            continue
        bb = sample.bbm.getCodeBlockAt(toAddr(int(node, 16)), monitor)
        if bb != None:
            if section.size > 0x0:
                if bb.getMinAddress().getOffset() > section.start and bb.getMaxAddress().getOffset() < section.end:
                    start = max(bb.getMinAddress().getOffset(), section.start)
                    end = min(bb.getMaxAddress().getOffset(), section.end)
                    if end >= start:
                        slot = 0
                        # Check if any address within the range is already used
                        for address in range(start, end + 1):
                            if address in used_addresses:
                                continue
                            # Update the used addresses
                            else:
                                slot += 1
                                used_addresses.add(address)
                        section.disass += slot
    for section in sample.sections:
        # remove 0x00 bytes
        zero_bytes = 0
        for addr in range(section.start, section.end):
            if not addr in used_addresses and getByte(toAddr(addr)) == 0:
                zero_bytes += 1
        # calculate the ratio
        if section.size > 0 and section.disass > 0:
            section.disass = (section.disass + zero_bytes) / section.size
        else:
            section.disass = 0.0


def bb_coverage():
    '''
    Compute the executed bbs based on the trace file
    '''
    for addr in sample.trace:
        bb = sample.bbm.getFirstCodeBlockContaining(toAddr(addr), monitor)
        if bb != None:
            # Get all the bbs executed per sample
            section = sample.find_section(
                bb.getFirstStartAddress().getOffset())
            if G.has_node(bb.getFirstStartAddress().toString()):
                sample.bb_exe.add(bb.getFirstStartAddress().toString())
                section.coverage += 1
                # Get all the bbs executed per function
                function = sample.find_function(
                    bb.getFirstStartAddress().getOffset())
                if function:
                    function.bb_exe.add(bb.getFirstStartAddress().toString())
            # TODO elif
            elif bb.getFirstStartAddress().toString() != "00000000":
                section.not_seen_set.add(
                    hex(bb.getFirstStartAddress().getOffset()))
    for sec in sample.sections:
        sec.not_seen = sorted(sec.not_seen_set)
        if sec.bbs > 0:
            sec.coverage = sec.coverage / sec.bbs
        else:
            sec.coverage = 0.0


def bb_functions():
    '''
    Compute all stats on bbs and api for each function
    '''
    # Count bb disassembled
    for node in G.nodes():
        sec = sample.find_section(node)
        if sec == None:
            continue
        # Find functions
        function = sample.find_function(node)
        if function:
            function.tot_bb += 1
            if node in sample.ext_cover:
                function.tot_api += len(sample.ext_cover[node])
                # Put in the list all the api for that function
                function.api_not_executed.extend(sample.ext_cover[node])
    # Count bb executed
    for bb in sample.bb_exe:
        sec = sample.find_section(bb)
        if sec == None:
            continue
        # Find functions
        function = sample.find_function(bb)
        if function:
            function.exe_bb += 1
            if bb in sample.ext_cover:
                function.exe_api += len(sample.ext_cover[bb])
                # Remove the api called
                for api in sample.ext_cover[bb]:
                    if api in function.api_not_executed:
                        function.api_not_executed.remove(api)


def heap_coverage():
    for addr in sample.trace:
        for heap in sample.heaps:
            if heap.contains(addr):
                heap.instr_exec += 1
    # TODO add heap disass
    for heap in sample.heaps:
        if heap.instr_disass > 0 and heap.instr_exec > 0:
            heap.ratio = heap.instr_exec / heap.instr_disass


def instr_coverage():
    contained = False
    unknown_instr_set = set()
    for addr in sample.trace:
        # Sections
        for sec in sample.sections:
            if sec.contains(addr):
                contained = True
        # Heaps
        for heap in sample.heaps:
            if heap.contains(addr):
                contained = True
        # Modules
        for module in sample.modules:
            if module.contains(addr):
                module.instr_exec += 1
                contained = True
        # Unknown
        if not contained and addr != 0x0:
            unknown_instr_set.add(hex(addr))
        else:
            contained = False
    sample.unknown_instr = sorted(unknown_instr_set)


def edge_coverage():
    # Get the executed function graph (subset)
    subgraph = G.subgraph(sample.bb_exe)
    edges_exe = len(subgraph.edges())
    edges_tot = len(G.edges())
    if edges_tot != 0:
        sample.edge_coverage = edges_exe / edges_tot
    # Edge coverage for functions
    for sec in sample.sections:
        for function in sec.functions.values():
            # Get the function graph
            function.graph = G.subgraph(function.bb)
            # Get the executed function graph (subset)
            subgraph = function.graph.subgraph(function.bb_exe)
            edges_exe = len(subgraph.edges())
            edges_tot = len(function.graph.edges())
            if edges_tot != 0:
                function.edge_coverage = edges_exe / edges_tot


def basic_block(address):
    '''
    Analyze a single basic block
    '''
    if getInstructionContaining(address) == None:
        disassemble(address)
    bb = sample.bbm.getFirstCodeBlockContaining(address, monitor)
    if bb != None:
        node1 = bb.getFirstStartAddress()
        G.add_node(node1.toString())
        # Check if there are other possible functions not called directly
        checkIndirectBlocks(node1)
        # Get visited bb of a function
        func = sample.find_function(address.getOffset())
        if func:
            func.bb.add(bb.getFirstStartAddress().toString())
        # Get destinations
        dests = bb.getDestinations(monitor)
        while (dests.hasNext()):
            dbb = dests.next()
            # Add adresses to the list
            if dbb != None:
                node2 = dbb.getReference()
                sample.addr_to_visit.insert(0, node2.getOffset())
                # Create the edge
                print("\t[*] {" + node1.toString() + "} ->{" +
                      node2.toString() + "}", file=log)
                G.add_edge(node1.toString(), node2.toString())


def main():
    while len(sample.addr_to_visit) > 0:
        addr = sample.addr_to_visit.pop()
        if not addr in sample.addr_visited:
            basic_block(toAddr(addr))
            sample.addr_visited.append(addr)
    # Export the graph
    with open('graph.pickle', 'wb') as file:
        pickle.dump(G, file)
    # Stats
    bb_disassembled_ratio()
    bb_coverage()
    bb_functions()
    heap_coverage()
    instr_coverage()
    edge_coverage()


# Starts execution here
if __name__ == "__main__":
    print("Start")

    G = nx.Graph()
    monitor = getMonitor()
    # Sample
    sample = Sample(str(getProgramFile()))
    # Main program
    log = open("log.txt", "w")
    main()
    log.close()
    # Print
    print(sample)
    sample.json_sections()

    print("End")
